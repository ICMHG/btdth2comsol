# BTD Thermal JSON到COMSOL MPH转换器技术方案

## 1. 项目概述

### 1.1 项目目标
开发一个Python项目，将BTD Thermal格式的JSON文件转换为COMSOL MPH文件，用于热仿真分析。项目基于现有的C++代码架构，使用MPh库作为COMSOL接口。

### 1.2 技术栈
- **开发语言**: Python 3.10
- **COMSOL接口**: MPh库 (https://github.com/MPh-py/MPh)
- **参考架构**: 现有C++代码 (material/ 和 thermal_base/ 文件夹)
- **几何处理**: 支持多种3D形状和装配体结构

## 2. 核心架构分析

### 2.1 数据模型层次结构

基于C++代码分析，系统的核心数据模型采用以下层次结构：

```
ThermalInfo (核心管理器)
├── MaterialInfosMgr (材料管理器)
│   ├── MaterialInfo (材料信息)
│   │   ├── TemperaturePoint (温度点)
│   │   └── Conductivity (热导率)
│   └── CompositeMaterial (复合材料)
│       └── ObjectMaterial (对象材料)
├── Sections (几何区域)
│   ├── Section (基础区域)
│   │   └── SectionComponent (子组件)
│   └── StackedDieSection (堆叠芯片)
│       └── PkgComponent (封装组件)
├── Shape System (形状系统)
│   ├── Shape (基础形状)
│   │   ├── Cube (立方体)
│   │   ├── Cylinder (圆柱体)
│   │   ├── HexagonalPrism (六棱柱)
│   │   ├── ObliqueCube (斜立方体)
│   │   └── Prism (棱柱)
│   └── Shape2D (2D形状)
├── Parameters (参数系统)
│   ├── Parameters (基础参数)
│   └── ThermalPara (热分析参数)
│       ├── PackagePara (封装参数)
│       ├── HeatSinkPara (散热器参数)
│       └── TestBoardPara (测试板参数)
└── Supporting Systems
    ├── VerticalInterconnectManager (垂直互连管理器)
    ├── PowerMap (功率映射)
    └── Constraints (约束条件)
```

### 2.2 ThermalInfo的核心作用

**ThermalInfo是整个系统的核心数据结构**，它：

1. **统一数据管理**：
   - 管理所有材料定义和属性
   - 管理几何区域和层次结构
   - 管理封装组件和堆叠芯片
   - 管理热分析参数和约束条件

2. **提供数据访问接口**：
   - `getAllSection()`: 获取所有几何区域
   - `getPkgSection()`: 获取封装相关区域
   - `getStackDiesSection()`: 获取堆叠芯片区域
   - `getRuntimeSections()`: 获取运行时处理后的区域

3. **处理复杂几何关系**：
   - 管理层次化几何结构
   - 处理父子关系（Section -> SectionComponent）
   - 处理堆叠芯片结构（PkgComponent -> StackedDieSection）

## 3. 形状系统设计

### 3.1 形状类型支持

基于shape文件夹分析，系统支持以下形状类型：

**3D形状类型**：
- `Cube`: 立方体 - `cube([x,y,z], length, width, height)`
- `Cylinder`: 圆柱体 - `cylinder([x,y,z], radius, height)`
- `HexagonalPrism`: 六棱柱 - `hexagonal_prism([x,y,z], radius, height)`
- `ObliqueCube`: 斜立方体 - `oblique_cube(start, end, width, thickness)`
- `Prism`: 棱柱 - `prism(polygon_path, thickness)`
- `RectPrism`: 矩形棱柱
- `SquarePrism`: 正方形棱柱
- `OblongXPrism`: X方向椭圆形棱柱
- `OblongYPrism`: Y方向椭圆形棱柱
- `RoundedRectPrism`: 圆角矩形棱柱
- `ChamferedRectPrism`: 倒角矩形棱柱
- `NSidedPolygonPrism`: N边形棱柱

**2D形状类型**：
- `Circle`: 圆形
- `Rectangle`: 矩形
- `Square`: 正方形
- `OblongX`: X方向椭圆形
- `OblongY`: Y方向椭圆形
- `RoundedRectangle`: 圆角矩形
- `ChamferedRectangle`: 倒角矩形
- `NSidedPolygon`: N边形

### 3.2 形状解析策略

```python
class ShapeParser:
    def parse_shape_string(self, shape_string):
        """解析形状字符串，返回形状对象"""
        # 解析 "cube([x,y,z], length, width, height)" 格式
        import re
        
        # 立方体解析
        cube_pattern = r"cube\(\[([^,]+),([^,]+),([^,]+)\],([^,]+),([^,]+),([^,]+)\)"
        match = re.match(cube_pattern, shape_string)
        if match:
            x, y, z = float(match.group(1)), float(match.group(2)), float(match.group(3))
            length, width, height = float(match.group(4)), float(match.group(5)), float(match.group(6))
            return Cube(Vector3D(x, y, z), length, width, height)
            
        # 圆柱体解析
        cylinder_pattern = r"cylinder\(\[([^,]+),([^,]+),([^,]+)\],([^,]+),([^,]+)\)"
        match = re.match(cylinder_pattern, shape_string)
        if match:
            x, y, z = float(match.group(1)), float(match.group(2)), float(match.group(3))
            radius, height = float(match.group(4)), float(match.group(5))
            return Cylinder(Vector3D(x, y, z), radius, height)
            
        # 其他形状解析...
```

## 4. 材料系统设计

### 4.1 材料属性结构

**MaterialInfo类**：
```python
class MaterialInfo:
    def __init__(self, name):
        self.name = name
        self.temperature_map = {}  # 温度到属性的映射
        
    def add_temperature_point(self, temperature, conductivity_x, conductivity_y, conductivity_z, 
                             density, heat_capacity, electrical_migration, solar_reflectance):
        """添加温度点数据"""
        conductivity = Conductivity(conductivity_x, conductivity_y, conductivity_z)
        point = TemperaturePoint(temperature, conductivity, density, heat_capacity, 
                                electrical_migration, solar_reflectance)
        self.temperature_map[temperature] = point
        
    def get_conductivity(self, temperature=293.15):
        """获取指定温度下的热导率（支持插值）"""
        return self.interpolate_property(temperature, lambda p: p.conductivity)
        
    def interpolate_property(self, temperature, property_getter):
        """线性插值算法"""
        # 实现温度插值逻辑
```

**CompositeMaterial类**：
```python
class CompositeMaterial:
    def __init__(self):
        self.materials = []  # [(material, percentage), ...]
        
    def add_material(self, material, percentage):
        """添加材料及其体积分数"""
        self.materials.append((material, percentage))
        
    def get_effective_conductivity(self, temperature=293.15):
        """计算有效热导率（体积加权平均）"""
        total_conductivity = 0.0
        for material, percentage in self.materials:
            conductivity = material.get_conductivity(temperature)
            total_conductivity += conductivity * percentage
        return total_conductivity
```

### 4.2 温度依赖性处理

系统支持材料属性的温度依赖性，通过以下方式实现：

1. **多温度点数据**：每个材料可以定义多个温度点的属性值
2. **线性插值**：在温度点之间进行线性插值
3. **边界处理**：超出温度范围时使用最近温度点的值
4. **复合材料混合**：支持多种材料的体积加权混合

## 5. 几何层次结构设计

### 5.1 基础组件层次

```
BaseComponent (基础组件)
├── Shape (形状)
├── Material (材料)
├── Position (位置)
└── Type (类型)

Section (几何区域) - 继承自BaseComponent
├── Layer (层)
├── TypeStr (类型字符串)
├── Children (子组件列表)
└── Thickness (厚度)

SectionComponent (区域组件) - 继承自BaseComponent
└── TemplateName (模板名称)

StackedDieSection (堆叠芯片) - 继承自Section
├── PowerType (功率类型)
├── PowerMapFile (功率映射文件)
├── StackTier (堆叠层级)
├── Bump (凸点连接)
└── Dies (子芯片列表)

PkgComponent (封装组件) - 继承自StackedDieSection
├── RefDes (参考标识)
├── MdlName (模型名称)
├── AttachLayer (附着层)
└── PackagePara (封装参数)
```

### 5.2 几何关系处理

**父子关系**：
- Section可以包含多个SectionComponent作为子组件
- 子组件通过布尔运算与父组件关联
- 支持差集、并集等布尔操作

**堆叠关系**：
- PkgComponent可以包含多个StackedDieSection
- 每个StackedDieSection代表一个芯片层
- 层间通过Bump连接

## 6. 解析器设计

### 6.1 主解析器架构

```python
class BTDJsonParser:
    def __init__(self):
        self.thermal_info = None
        
    def parse(self, json_data, json_file_path=None):
        """解析JSON数据，创建ThermalInfo对象"""
        # 创建ThermalInfo对象
        self.thermal_info = ThermalInfo()
        
        # 设置JSON文件目录（用于相对路径解析）
        if json_file_path:
            self.thermal_info.set_json_file_dir(json_file_path.parent)
        
        # 按顺序解析各个部分
        self.parse_materials(json_data.get("materials", []))
        self.parse_templates(json_data.get("templates", []))
        self.parse_sections(json_data.get("sections", []))
        self.parse_parts(json_data.get("parts", []))
        self.parse_parameters(json_data.get("parameters", {}))
        self.parse_thermal_parameters(json_data.get("thermal", {}))
        self.parse_netlist(json_data.get("netlist", {}))
        self.parse_component_connect(json_data.get("ComponentConnect", []))
        self.parse_part_info(json_data.get("Part", []))
        self.parse_constraints(json_data.get("Constraints", {}))
        
        return self.thermal_info
```

### 6.2 专用解析器

**材料解析器**：
```python
class MaterialParser:
    def parse_materials(self, materials_data):
        """解析材料定义"""
        for material_data in materials_data:
            material_info = MaterialInfo(material_data["name"])
            
            # 解析温度依赖性属性
            for prop_data in material_data["t_kx_ky_kz_rho_hc_em_ref_properties"]:
                temperature = prop_data[0]
                conductivity_x, conductivity_y, conductivity_z = prop_data[1:4]
                density, heat_capacity = prop_data[4:6]
                electrical_migration, solar_reflectance = prop_data[6:8]
                
                material_info.add_temperature_point(
                    temperature, conductivity_x, conductivity_y, conductivity_z,
                    density, heat_capacity, electrical_migration, solar_reflectance
                )
            
            self.thermal_info.get_materials_mgr().add_material(material_info)
```

**几何解析器**：
```python
class GeometryParser:
    def parse_sections(self, sections_data):
        """解析几何区域"""
        for section_data in sections_data:
            section = Section()
            
            # 解析基本信息
            section.set_name(section_data.get("name", ""))
            section.set_layer(section_data.get("layer", ""))
            section.set_type_str(section_data.get("type", ""))
            
            # 解析形状
            shape_string = section_data.get("shape", "")
            shape = self.shape_parser.parse_shape_string(shape_string)
            section.set_shape(shape)
            
            # 解析材料
            materials_data = section_data.get("materials", [])
            composite_material = self.parse_composite_materials(materials_data)
            section.set_material(composite_material)
            
            # 解析子组件
            children_data = section_data.get("children", [])
            for child_data in children_data:
                child = self.parse_section_component(child_data)
                section.add_component(child)
            
            self.thermal_info.add_section(section)
```

## 7. COMSOL转换器设计

### 7.1 主转换器架构

```python
class MPHConverter:
    def __init__(self):
        self.model = None
        
    def convert(self, thermal_info, output_file):
        """基于ThermalInfo对象创建COMSOL模型"""
        # 创建COMSOL模型
        self.model = mph.Model()
        
        # 1. 创建装配体
        assembly = self.create_assembly()
        
        # 2. 添加所有几何区域
        self.add_all_sections_to_assembly(assembly, thermal_info)
        
        # 3. 设置材料
        self.setup_materials(thermal_info)
        
        # 4. 设置热物理场
        self.setup_heat_transfer(thermal_info)
        
        # 5. 设置边界条件
        self.setup_boundary_conditions(thermal_info)
        
        # 6. 生成网格
        self.generate_mesh()
        
        # 7. 设置求解器
        self.setup_solver(thermal_info)
        
        # 8. 保存文件
        self.model.save(output_file)
```

### 7.2 装配体几何转换

```python
class AssemblyGeometryConverter:
    def create_assembly(self, model):
        """创建COMSOL装配体"""
        assembly = model.geom.create("assembly", 3)
        return assembly
        
    def add_section_to_assembly(self, assembly, section, parent_name=""):
        """将Section添加到装配体"""
        # 创建几何对象
        geom_name = f"geom_{section.name}"
        geom = assembly.geom.create(geom_name, 3)
        
        # 添加主形状
        self.add_shape_to_geometry(geom, section.shape)
        
        # 递归处理子组件
        for child in section.children:
            self.add_child_to_geometry(geom, child)
            
        # 设置布尔运算
        if section.children:
            self.setup_boolean_operations(geom, section.children)
            
    def add_shape_to_geometry(self, geom, shape):
        """将Shape对象添加到COMSOL几何"""
        if isinstance(shape, Cube):
            self.add_cube_to_geometry(geom, shape)
        elif isinstance(shape, Cylinder):
            self.add_cylinder_to_geometry(geom, shape)
        elif isinstance(shape, HexagonalPrism):
            self.add_hexagonal_prism_to_geometry(geom, shape)
        # 其他形状类型...
        
    def add_cube_to_geometry(self, geom, cube):
        """添加立方体到COMSOL几何"""
        block = geom.feature().create("block", "Block")
        block.set("size", [cube.length, cube.width, cube.thickness])
        block.set("pos", [cube.position.x, cube.position.y, cube.position.z])
```

### 7.3 材料转换

```python
class MaterialConverter:
    def setup_materials(self, thermal_info):
        """设置COMSOL材料"""
        # 获取所有使用的材料名称
        material_names = thermal_info.get_all_used_material_names()
        
        # 创建材料对象
        for material_name in material_names:
            material_info = thermal_info.get_materials_mgr().get_material(material_name)
            self.create_comsol_material(material_info)
            
    def create_comsol_material(self, material_info):
        """创建COMSOL材料"""
        material = self.model.material.create(f"mat_{material_info.name}")
        
        # 设置温度依赖性属性
        if material_info.is_temperature_dependent():
            self.set_temperature_dependent_properties(material, material_info)
        else:
            self.set_constant_properties(material, material_info)
            
    def set_temperature_dependent_properties(self, material, material_info):
        """设置温度依赖性材料属性"""
        # 创建温度函数
        temp_func = self.model.func.create("temp_func", "Analytic")
        temp_func.set("expr", "T")
        
        # 设置热导率函数
        k_func = self.model.func.create(f"k_{material_info.name}", "Analytic")
        k_expr = self.create_conductivity_expression(material_info)
        k_func.set("expr", k_expr)
        
        # 设置材料属性
        material.prop("thermal_conductivity").set("k", k_func)
```

### 7.4 热物理场设置

```python
class HeatTransferSetup:
    def setup_heat_transfer(self, thermal_info):
        """设置热传递物理场"""
        # 创建热传递物理场
        heat_transfer = self.model.physics.create("heat", "HeatTransferInSolids")
        
        # 设置热源
        self.setup_heat_sources(heat_transfer, thermal_info)
        
        # 设置边界条件
        self.setup_boundary_conditions(heat_transfer, thermal_info)
        
    def setup_heat_sources(self, heat_transfer, thermal_info):
        """设置热源"""
        # 从parameters中获取功率信息
        powers = thermal_info.parameters.get_powers()
        
        # 从封装组件中获取功率映射
        for component in thermal_info.pkg_die.get_components():
            if component.power_type == PowerType.POWER_MAP:
                self.setup_power_map_source(component, heat_transfer)
            elif component.power_type == PowerType.TOTAL_POWER:
                self.setup_total_power_source(component, heat_transfer)
                
    def setup_boundary_conditions(self, heat_transfer, thermal_info):
        """设置边界条件"""
        # 获取热分析参数
        thermal_para = thermal_info.get_thermal_para()
        
        # 设置环境温度
        ambient_temp = thermal_info.parameters.get_ambient_temperature()
        
        # 设置对流边界条件
        if thermal_para.get_heat_sink_para().is_use_heat_sink():
            self.setup_convection_boundary(heat_transfer, thermal_para)
```

## 8. 详细数据流程设计

### 8.1 完整转换流程

```
1. JSON文件输入
   ├── 文件格式验证
   ├── 编码检查
   └── 基础语法验证
   ↓
2. BTDJsonParser解析
   ├── 解析材料定义 → MaterialInfosMgr
   │   ├── 解析材料名称和类型
   │   ├── 解析温度依赖性属性数组
   │   ├── 验证材料属性完整性
   │   └── 创建MaterialInfo对象
   ├── 解析templates → VerticalInterconnectManager
   │   ├── 解析垂直互连模板
   │   ├── 创建PadStack对象
   │   └── 设置模板参数
   ├── 解析sections → Sections
   │   ├── 解析基础几何区域
   │   ├── 解析形状定义字符串
   │   ├── 解析材料分配
   │   ├── 解析子组件层次结构
   │   └── 创建Section对象
   ├── 解析parts → PkgDie
   │   ├── 解析封装组件定义
   │   ├── 解析堆叠芯片结构
   │   ├── 解析bump连接信息
   │   ├── 解析功率映射文件路径
   │   └── 创建PkgComponent对象
   ├── 解析parameters → Parameters
   │   ├── 解析环境参数
   │   ├── 解析热通量参数
   │   └── 解析单位设置
   ├── 解析thermal → ThermalPara
   │   ├── 解析PackagePara（封装参数）
   │   ├── 解析HeatSinkPara（散热器参数）
   │   └── 解析TestBoardPara（测试板参数）
   ├── 解析netlist → Netlist
   │   ├── 解析网络连接信息
   │   └── 创建网络拓扑
   ├── 解析ComponentConnect → PartComponentMgr
   │   ├── 解析组件连接信息
   │   └── 建立连接关系
   ├── 解析Part → PartComponentMgr
   │   ├── 解析部件信息
   │   └── 创建Part对象
   └── 解析Constraints → Constraints
       ├── 解析约束条件
       └── 设置边界约束
   ↓
3. ThermalInfo数据验证和预处理
   ├── 材料完整性检查
   │   ├── 验证所有引用的材料是否存在
   │   ├── 检查材料属性数据完整性
   │   ├── 验证温度依赖性数据连续性
   │   └── 检查复合材料比例合理性
   ├── 几何一致性验证
   │   ├── 验证形状定义语法正确性
   │   ├── 检查几何尺寸合理性
   │   ├── 验证层次结构完整性
   │   ├── 检查布尔运算有效性
   │   └── 验证坐标系统一致性
   ├── 参数合理性检查
   │   ├── 验证热分析参数范围
   │   ├── 检查边界条件设置
   │   ├── 验证功率密度合理性
   │   └── 检查环境参数设置
   ├── 层次结构验证
   │   ├── 验证父子关系完整性
   │   ├── 检查堆叠芯片结构
   │   ├── 验证bump连接有效性
   │   └── 检查材料分配一致性
   └── 运行时几何处理
       ├── 按Z坐标排序所有Section
       ├── 处理薄层合并（可选配置）
       ├── 统一几何尺寸
       ├── 建立父子关系
       └── 应用布尔运算
   ↓
4. COMSOL模型创建
   ├── 创建装配体
   │   ├── 初始化COMSOL模型
   │   ├── 创建3D装配体几何
   │   └── 设置装配体参数
   ├── 添加几何对象
   │   ├── 创建基础几何形状
   │   ├── 设置几何参数和位置
   │   ├── 建立几何层次关系
   │   ├── 应用布尔运算
   │   └── 处理复杂几何结构
   ├── 设置材料属性
   │   ├── 创建COMSOL材料对象
   │   ├── 设置温度依赖性属性
   │   ├── 处理复合材料混合
   │   ├── 分配材料到几何区域
   │   └── 验证材料分配
   ├── 配置物理场
   │   ├── 创建热传递物理场
   │   ├── 设置热传导方程
   │   ├── 配置材料属性函数
   │   └── 设置物理场参数
   ├── 设置边界条件
   │   ├── 设置环境温度边界
   │   ├── 配置对流边界条件
   │   ├── 设置热源边界
   │   ├── 配置散热器边界
   │   └── 设置绝热边界
   ├── 生成网格
   │   ├── 设置网格参数
   │   ├── 生成体网格
   │   ├── 优化网格质量
   │   └── 验证网格有效性
   └── 配置求解器
       ├── 设置求解器类型
       ├── 配置求解参数
       ├── 设置收敛条件
       └── 配置输出选项
   ↓
5. MPH文件输出
   ├── 验证模型完整性
   ├── 检查求解器设置
   ├── 保存MPH文件
   └── 生成转换报告
```

### 8.2 详细处理步骤

#### 8.2.1 几何层次处理详细流程

**步骤1：几何数据收集和排序**
```python
def process_geometry_hierarchy(thermal_info):
    """处理几何层次结构"""
    # 1. 收集所有几何区域
    all_sections = thermal_info.get_all_sections()
    
    # 2. 按Z坐标排序
    sorted_sections = sorted(all_sections, key=lambda s: s.get_offset_z())
    
    # 3. 建立层次关系映射
    hierarchy_map = build_hierarchy_map(sorted_sections)
    
    # 4. 验证层次结构完整性
    validate_hierarchy_integrity(hierarchy_map)
    
    return sorted_sections, hierarchy_map
```

**步骤2：薄层合并处理**
```python
def merge_thin_layers(sections, ignore_thickness=0.1):
    """合并薄层"""
    merged_sections = []
    current_section = None
    
    for section in sections:
        if section.get_thickness() <= ignore_thickness:
            if current_section:
                # 合并到当前section
                current_section.merge_thin_layer(section)
            else:
                current_section = section
        else:
            if current_section:
                merged_sections.append(current_section)
            current_section = section
    
    if current_section:
        merged_sections.append(current_section)
    
    return merged_sections
```

**步骤3：几何尺寸统一**
```python
def unify_geometry_dimensions(sections):
    """统一几何尺寸"""
    # 计算全局边界框
    global_bbox = calculate_global_bounding_box(sections)
    
    # 为每个section创建统一的几何尺寸
    for section in sections:
        # 保持原有厚度和位置
        thickness = section.get_thickness()
        z_position = section.get_offset_z()
        
        # 使用全局边界框的长宽
        new_shape = create_unified_shape(
            global_bbox, thickness, z_position, section.get_rotation()
        )
        section.set_shape(new_shape)
```

**步骤4：父子关系建立**
```python
def establish_parent_child_relationships(sections):
    """建立父子关系"""
    for section in sections:
        # 查找子组件
        children = find_child_components(section)
        
        # 建立布尔运算关系
        for child in children:
            boolean_operation = determine_boolean_operation(section, child)
            section.add_child_with_operation(child, boolean_operation)
```

#### 8.2.2 材料分配详细流程

**步骤1：材料收集和验证**
```python
def collect_and_validate_materials(thermal_info):
    """收集和验证材料"""
    # 获取所有使用的材料名称
    material_names = thermal_info.get_all_used_material_names()
    
    # 验证材料存在性
    missing_materials = []
    for name in material_names:
        if not thermal_info.get_materials_mgr().has_material(name):
            missing_materials.append(name)
    
    if missing_materials:
        raise MaterialNotFoundError(f"Missing materials: {missing_materials}")
    
    return material_names
```

**步骤2：COMSOL材料创建**
```python
def create_comsol_materials(model, thermal_info, material_names):
    """创建COMSOL材料"""
    materials_dict = {}
    
    for material_name in material_names:
        material_info = thermal_info.get_materials_mgr().get_material(material_name)
        
        # 创建COMSOL材料对象
        comsol_material = model.material.create(f"mat_{material_name}")
        
        # 设置材料属性
        if material_info.is_temperature_dependent():
            setup_temperature_dependent_material(comsol_material, material_info, model)
        else:
            setup_constant_material(comsol_material, material_info)
        
        materials_dict[material_name] = comsol_material
    
    return materials_dict
```

**步骤3：温度依赖性材料设置**
```python
def setup_temperature_dependent_material(comsol_material, material_info, model):
    """设置温度依赖性材料"""
    # 创建温度函数
    temp_func = model.func.create(f"temp_{material_info.name}", "Analytic")
    temp_func.set("expr", "T")
    
    # 创建热导率函数
    k_func = create_conductivity_function(model, material_info)
    
    # 创建密度函数
    rho_func = create_density_function(model, material_info)
    
    # 创建比热容函数
    cp_func = create_heat_capacity_function(model, material_info)
    
    # 设置材料属性
    comsol_material.prop("thermal_conductivity").set("k", k_func)
    comsol_material.prop("density").set("rho", rho_func)
    comsol_material.prop("heat_capacity").set("cp", cp_func)
```

**步骤4：复合材料处理**
```python
def setup_composite_material(comsol_material, composite_material, model):
    """设置复合材料"""
    # 计算有效属性
    effective_props = calculate_effective_properties(composite_material)
    
    # 创建有效属性函数
    k_eff_func = create_effective_conductivity_function(model, effective_props)
    rho_eff_func = create_effective_density_function(model, effective_props)
    cp_eff_func = create_effective_heat_capacity_function(model, effective_props)
    
    # 设置材料属性
    comsol_material.prop("thermal_conductivity").set("k", k_eff_func)
    comsol_material.prop("density").set("rho", rho_eff_func)
    comsol_material.prop("heat_capacity").set("cp", cp_eff_func)
```

#### 8.2.3 热源设置详细流程

**步骤1：功率映射文件解析**
```python
def parse_power_map_file(file_path, component):
    """解析功率映射文件"""
    power_data = {}
    
    # 读取功率映射文件
    with open(file_path, 'r') as f:
        # 解析文件格式（根据具体格式实现）
        power_data = parse_power_map_format(f)
    
    # 验证功率数据
    validate_power_data(power_data, component)
    
    return power_data
```

**步骤2：体积热源创建**
```python
def create_volume_heat_sources(heat_transfer, thermal_info):
    """创建体积热源"""
    # 获取所有有功率的组件
    powered_components = get_powered_components(thermal_info)
    
    for component in powered_components:
        if component.power_type == PowerType.POWER_MAP:
            # 创建功率映射热源
            create_power_map_heat_source(heat_transfer, component)
        elif component.power_type == PowerType.TOTAL_POWER:
            # 创建均匀热源
            create_uniform_heat_source(heat_transfer, component)
```

**步骤3：表面热源设置**
```python
def setup_surface_heat_sources(heat_transfer, thermal_info):
    """设置表面热源"""
    # 获取表面热源参数
    surface_heat_flux = thermal_info.parameters.get_surface_heat_flux()
    
    if surface_heat_flux > 0:
        # 创建表面热源
        surface_source = heat_transfer.feature().create("surf_heat", "HeatFlux")
        surface_source.set("Q0", surface_heat_flux)
        
        # 选择表面
        surfaces = select_heat_source_surfaces(thermal_info)
        surface_source.selection().set(surfaces)
```

**步骤4：功率密度分布配置**
```python
def configure_power_density_distribution(heat_transfer, power_data, component):
    """配置功率密度分布"""
    # 创建功率密度函数
    power_density_func = create_power_density_function(power_data, component)
    
    # 创建体积热源
    volume_source = heat_transfer.feature().create("vol_heat", "HeatSource")
    volume_source.set("Q", power_density_func)
    
    # 选择体积
    volume = select_component_volume(component)
    volume_source.selection().set(volume)
```



## 9. 核心算法详细设计

### 9.1 形状解析算法详细设计

#### 9.1.1 立方体解析算法
```python
def parse_cube_shape(shape_string):
    """解析立方体形状字符串"""
    # 解析格式: cube([x,y,z], length, width, height)
    import re
    
    pattern = r"cube\(\[([^,]+),([^,]+),([^,]+)\],([^,]+),([^,]+),([^,]+)\)"
    match = re.match(pattern, shape_string)
    
    if not match:
        raise ShapeParsingError(f"Invalid cube format: {shape_string}")
    
    try:
        x = float(match.group(1))
        y = float(match.group(2))
        z = float(match.group(3))
        length = float(match.group(4))
        width = float(match.group(5))
        height = float(match.group(6))
        
        # 验证尺寸
        if length <= 0 or width <= 0 or height <= 0:
            raise ShapeParsingError("Cube dimensions must be positive")
        
        return Cube(Vector3D(x, y, z), length, width, height)
    except ValueError as e:
        raise ShapeParsingError(f"Invalid numeric values in cube: {e}")
```

#### 9.1.2 圆柱体解析算法
```python
def parse_cylinder_shape(shape_string):
    """解析圆柱体形状字符串"""
    # 解析格式: cylinder([x,y,z], radius, height)
    import re
    
    pattern = r"cylinder\(\[([^,]+),([^,]+),([^,]+)\],([^,]+),([^,]+)\)"
    match = re.match(pattern, shape_string)
    
    if not match:
        raise ShapeParsingError(f"Invalid cylinder format: {shape_string}")
    
    try:
        x = float(match.group(1))
        y = float(match.group(2))
        z = float(match.group(3))
        radius = float(match.group(4))
        height = float(match.group(5))
        
        # 验证尺寸
        if radius <= 0 or height <= 0:
            raise ShapeParsingError("Cylinder radius and height must be positive")
        
        return Cylinder(Vector3D(x, y, z), radius, height)
    except ValueError as e:
        raise ShapeParsingError(f"Invalid numeric values in cylinder: {e}")
```

#### 9.1.3 六棱柱解析算法
```python
def parse_hexagonal_prism_shape(shape_string):
    """解析六棱柱形状字符串"""
    # 解析格式: hexagonal_prism([x,y,z], radius, height)
    import re
    
    pattern = r"hexagonal_prism\(\[([^,]+),([^,]+),([^,]+)\],([^,]+),([^,]+)\)"
    match = re.match(pattern, shape_string)
    
    if not match:
        raise ShapeParsingError(f"Invalid hexagonal prism format: {shape_string}")
    
    try:
        x = float(match.group(1))
        y = float(match.group(2))
        z = float(match.group(3))
        radius = float(match.group(4))
        height = float(match.group(5))
        
        # 验证尺寸
        if radius <= 0 or height <= 0:
            raise ShapeParsingError("Hexagonal prism radius and height must be positive")
        
        return HexagonalPrism(Vector3D(x, y, z), radius, height)
    except ValueError as e:
        raise ShapeParsingError(f"Invalid numeric values in hexagonal prism: {e}")
```

### 9.2 材料插值算法详细设计

#### 9.2.1 线性插值算法
```python
def linear_interpolate(temperature_points, target_temperature, property_getter):
    """线性插值算法"""
    if not temperature_points:
        raise ValueError("No temperature points provided")
    
    # 按温度排序
    sorted_points = sorted(temperature_points, key=lambda p: p.temperature)
    
    # 边界检查
    min_temp = sorted_points[0].temperature
    max_temp = sorted_points[-1].temperature
    
    if target_temperature <= min_temp:
        return property_getter(sorted_points[0])
    elif target_temperature >= max_temp:
        return property_getter(sorted_points[-1])
    
    # 查找相邻温度点
    for i in range(len(sorted_points) - 1):
        temp1 = sorted_points[i].temperature
        temp2 = sorted_points[i + 1].temperature
        
        if temp1 <= target_temperature <= temp2:
            # 执行线性插值
            value1 = property_getter(sorted_points[i])
            value2 = property_getter(sorted_points[i + 1])
            
            # 计算插值权重
            weight = (target_temperature - temp1) / (temp2 - temp1)
            
            # 线性插值
            interpolated_value = value1 + weight * (value2 - value1)
            return interpolated_value
    
    # 如果没找到合适的区间，返回最近的值
    return property_getter(sorted_points[-1])
```

#### 9.2.2 复合材料混合算法
```python
def calculate_composite_properties(composite_material, temperature=293.15):
    """计算复合材料有效属性"""
    if not composite_material.materials:
        raise ValueError("No materials in composite")
    
    # 验证体积分数总和
    total_percentage = sum(mat.percentage for mat in composite_material.materials)
    if abs(total_percentage - 1.0) > 1e-6:
        raise ValueError(f"Material percentages must sum to 1.0, got {total_percentage}")
    
    # 计算有效热导率（体积加权平均）
    effective_conductivity = 0.0
    for material_info, percentage in composite_material.materials:
        conductivity = material_info.get_conductivity(temperature)
        effective_conductivity += conductivity * percentage
    
    # 计算有效密度（体积加权平均）
    effective_density = 0.0
    for material_info, percentage in composite_material.materials:
        density = material_info.get_density(temperature)
        effective_density += density * percentage
    
    # 计算有效比热容（体积加权平均）
    effective_heat_capacity = 0.0
    for material_info, percentage in composite_material.materials:
        heat_capacity = material_info.get_heat_capacity(temperature)
        effective_heat_capacity += heat_capacity * percentage
    
    return {
        'conductivity': effective_conductivity,
        'density': effective_density,
        'heat_capacity': effective_heat_capacity
    }
```

### 9.3 几何层次处理算法详细设计

#### 9.3.1 几何排序算法
```python
def sort_sections_by_z_coordinate(sections):
    """按Z坐标排序sections"""
    # 使用稳定的排序算法
    sorted_sections = sorted(sections, key=lambda s: s.get_offset_z())
    
    # 验证排序结果
    for i in range(len(sorted_sections) - 1):
        z1 = sorted_sections[i].get_offset_z()
        z2 = sorted_sections[i + 1].get_offset_z()
        if z1 > z2:
            raise ValueError(f"Sorting failed: {z1} > {z2}")
    
    return sorted_sections
```

#### 9.3.2 薄层合并算法
```python
def merge_thin_layers(sections, threshold=0.1):
    """合并薄层算法"""
    if not sections:
        return sections
    
    merged_sections = []
    current_section = None
    accumulated_thickness = 0.0
    
    for section in sections:
        thickness = section.get_thickness()
        
        if thickness <= threshold:
            # 薄层，需要合并
            if current_section is None:
                current_section = section
                accumulated_thickness = thickness
            else:
                # 合并到当前section
                accumulated_thickness += thickness
                # 更新当前section的厚度
                current_section.set_thickness(accumulated_thickness)
        else:
            # 正常厚度层
            if current_section is not None:
                # 保存之前合并的section
                merged_sections.append(current_section)
                current_section = None
                accumulated_thickness = 0.0
            
            merged_sections.append(section)
    
    # 处理最后一个合并的section
    if current_section is not None:
        merged_sections.append(current_section)
    
    return merged_sections
```

#### 9.3.3 几何尺寸统一算法
```python
def unify_geometry_dimensions(sections):
    """统一几何尺寸算法"""
    if not sections:
        return sections
    
    # 计算全局边界框
    global_bbox = calculate_global_bounding_box(sections)
    
    # 获取全局尺寸
    global_length = global_bbox.max_x - global_bbox.min_x
    global_width = global_bbox.max_y - global_bbox.min_y
    
    # 为每个section创建统一的几何尺寸
    for section in sections:
        # 保持原有厚度和Z位置
        thickness = section.get_thickness()
        z_position = section.get_offset_z()
        rotation = section.get_rotation()
        
        # 创建新的统一形状
        new_shape = create_unified_shape(
            global_bbox.min_x, global_bbox.min_y, z_position,
            global_length, global_width, thickness, rotation
        )
        
        section.set_shape(new_shape)
    
    return sections
```

### 9.4 COMSOL装配体创建算法详细设计

#### 9.4.1 装配体初始化算法
```python
def create_comsol_assembly(model):
    """创建COMSOL装配体"""
    try:
        # 创建3D装配体几何
        assembly = model.geom.create("assembly", 3)
        
        # 设置装配体参数
        assembly.set("createselection", True)
        assembly.set("show", True)
        
        return assembly
    except Exception as e:
        raise ComsolCreationError(f"Failed to create assembly: {e}")
```

#### 9.4.2 几何对象添加算法
```python
def add_geometry_to_assembly(assembly, section, section_index):
    """向装配体添加几何对象"""
    try:
        # 创建几何对象名称
        geom_name = f"geom_{section_index}_{section.get_name()}"
        
        # 创建几何对象
        geom = assembly.geom.create(geom_name, 3)
        
        # 根据形状类型添加几何
        shape = section.get_shape()
        
        if isinstance(shape, Cube):
            add_cube_to_geometry(geom, shape)
        elif isinstance(shape, Cylinder):
            add_cylinder_to_geometry(geom, shape)
        elif isinstance(shape, HexagonalPrism):
            add_hexagonal_prism_to_geometry(geom, shape)
        else:
            raise UnsupportedShapeError(f"Unsupported shape type: {type(shape)}")
        
        return geom
    except Exception as e:
        raise GeometryCreationError(f"Failed to add geometry: {e}")
```

#### 9.4.3 布尔运算算法
```python
def apply_boolean_operations(geometry, children):
    """应用布尔运算"""
    if not children:
        return geometry
    
    for i, child in enumerate(children):
        try:
            # 创建布尔运算特征
            boolean_feature = geometry.feature().create(f"bool_{i}", "BooleanOperation")
            
            # 设置布尔运算类型（默认为差集）
            boolean_feature.set("operation", "difference")
            
            # 添加子几何
            add_child_geometry(geometry, child, boolean_feature)
            
        except Exception as e:
            raise BooleanOperationError(f"Boolean operation failed: {e}")
    
    return geometry
```

### 9.5 材料分配算法详细设计

#### 9.5.1 材料创建算法
```python
def create_comsol_material(model, material_info):
    """创建COMSOL材料"""
    try:
        # 创建材料对象
        material_name = f"mat_{material_info.get_name()}"
        material = model.material.create(material_name)
        
        # 设置材料属性
        if material_info.is_temperature_dependent():
            setup_temperature_dependent_material(material, material_info, model)
        else:
            setup_constant_material(material, material_info)
        
        return material
    except Exception as e:
        raise MaterialCreationError(f"Failed to create material: {e}")
```

#### 9.5.2 温度依赖性材料设置算法
```python
def setup_temperature_dependent_material(material, material_info, model):
    """设置温度依赖性材料"""
    try:
        # 创建温度函数
        temp_func_name = f"temp_{material_info.get_name()}"
        temp_func = model.func.create(temp_func_name, "Analytic")
        temp_func.set("expr", "T")
        
        # 创建热导率函数
        k_func_name = f"k_{material_info.get_name()}"
        k_func = create_conductivity_function(model, material_info, k_func_name)
        
        # 创建密度函数
        rho_func_name = f"rho_{material_info.get_name()}"
        rho_func = create_density_function(model, material_info, rho_func_name)
        
        # 创建比热容函数
        cp_func_name = f"cp_{material_info.get_name()}"
        cp_func = create_heat_capacity_function(model, material_info, cp_func_name)
        
        # 设置材料属性
        material.prop("thermal_conductivity").set("k", k_func)
        material.prop("density").set("rho", rho_func)
        material.prop("heat_capacity").set("cp", cp_func)
        
    except Exception as e:
        raise MaterialSetupError(f"Failed to setup temperature dependent material: {e}")
```

#### 9.5.3 材料分配算法
```python
def assign_material_to_geometry(geometry, material):
    """将材料分配给几何对象"""
    try:
        # 获取几何对象的选择
        selection = geometry.selection()
        
        # 设置材料
        geometry.material().set("material", material)
        
        return True
    except Exception as e:
        raise MaterialAssignmentError(f"Failed to assign material: {e}")
```

## 10. 项目结构设计

```
project/
├── src/
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── thermal_info.py              # ThermalInfo核心类
│   │   ├── material_manager.py          # 材料管理器
│   │   └── geometry_manager.py          # 几何管理器
│   ├── models/
│   │   ├── __init__.py
│   │   ├── material.py                  # 材料模型
│   │   ├── geometry.py                  # 几何模型
│   │   ├── shape.py                     # 形状系统
│   │   ├── composite.py                 # 复合材料模型
│   │   ├── temperature_point.py         # 温度点模型
│   │   └── conductivity.py              # 热导率模型
│   ├── parser/
│   │   ├── __init__.py
│   │   ├── json_parser.py               # 主解析器
│   │   ├── material_parser.py           # 材料解析器
│   │   ├── geometry_parser.py           # 几何解析器
│   │   ├── shape_parser.py              # 形状解析器
│   │   ├── section_parser.py            # 区域解析器
│   │   ├── part_parser.py               # 部件解析器
│   │   └── parameter_parser.py          # 参数解析器
│   ├── converter/
│   │   ├── __init__.py
│   │   ├── mph_converter.py             # 主转换器
│   │   ├── geometry_converter.py        # 几何转换器
│   │   ├── material_converter.py        # 材料转换器
│   │   ├── physics_converter.py         # 物理场转换器
│   │   ├── assembly_converter.py        # 装配体转换器
│   │   ├── mesh_converter.py            # 网格转换器
│   │   └── solver_converter.py          # 求解器转换器
│   └── utils/
│       ├── __init__.py
│       ├── geometry_utils.py            # 几何工具函数
│       ├── material_utils.py            # 材料工具函数
│       ├── interpolation_utils.py       # 插值工具函数
│       └── boolean_utils.py             # 布尔运算工具
├── tests/
│   ├── __init__.py
│   ├── test_parser.py
│   ├── test_models.py
│   └── test_converter.py
├── examples/
│   ├── sample_input.json
│   └── sample_output.mph
├── requirements.txt
├── setup.py
└── main.py
```

## 11. 实施计划

### 11.1 开发阶段规划

**第一阶段：核心架构开发（4-6周）**
- 实现ThermalInfo核心类
- 实现基础材料系统（MaterialInfo、CompositeMaterial）
- 实现基础几何系统（Shape、Section、BaseComponent）
- 实现基础解析器框架

**第二阶段：解析器开发（3-4周）**
- 实现JSON解析器（BTDJsonParser）
- 实现材料解析器（MaterialParser）
- 实现几何解析器（GeometryParser）
- 实现形状解析器（ShapeParser）
- 实现参数解析器（ParameterParser）

**第三阶段：COMSOL转换器开发（4-5周）**
- 实现主转换器（MPHConverter）
- 实现几何转换器（GeometryConverter）
- 实现材料转换器（MaterialConverter）
- 实现物理场转换器（PhysicsConverter）
- 实现装配体转换器（AssemblyConverter）

**第四阶段：高级功能开发（3-4周）**
- 实现温度依赖性材料处理
- 实现复合材料混合算法
- 实现功率映射文件解析
- 实现热源设置功能
- 实现边界条件配置

**第五阶段：测试和优化（2-3周）**
- 单元测试和集成测试
- 性能优化
- 文档编写

### 11.2 关键技术难点和解决方案

**难点1：复杂几何形状的COMSOL转换**
- 解决方案：实现分层的几何转换策略，先处理基础形状，再处理复杂组合

**难点2：温度依赖性材料的COMSOL函数创建**
- 解决方案：使用COMSOL的Analytic函数，实现分段线性插值

**难点3：装配体中的布尔运算**
- 解决方案：使用COMSOL的Assembly功能，实现父子几何关系的布尔运算

**难点4：功率映射文件的解析和转换**
- 解决方案：实现通用的功率映射解析器，支持多种文件格式

## 12. 总结

本技术方案提供了一个完整的BTD Thermal JSON到COMSOL MPH转换器详细设计，具有以下特点：

### 12.1 核心优势

1. **以ThermalInfo为核心**：统一管理所有热分析相关数据，确保数据一致性和完整性
2. **完整的形状系统**：支持13种3D形状和8种2D形状，覆盖所有常见几何类型
3. **灵活的材料系统**：支持温度依赖性和复合材料，实现精确的材料建模
4. **层次化几何结构**：支持复杂的装配体结构，满足现代电子封装设计需求
5. **COMSOL装配体支持**：充分利用COMSOL的装配体功能，实现高效的热仿真

### 12.2 技术创新点

1. **智能几何处理**：自动处理薄层合并、几何尺寸统一等复杂几何操作
2. **温度插值算法**：实现高效的线性插值算法，支持任意温度点的材料属性计算
3. **复合材料混合**：实现体积加权平均的复合材料混合算法
4. **功率映射解析**：支持多种格式的功率映射文件解析和转换

### 12.3 应用价值

1. **提高设计效率**：自动化JSON到COMSOL的转换过程，减少手动操作
2. **保证数据一致性**：基于现有C++代码架构，确保数据格式的一致性
3. **支持复杂模型**：能够处理现代电子封装中的复杂几何和材料结构
4. **降低学习成本**：保持与现有系统的兼容性，降低用户学习成本

该方案基于现有C++代码的架构设计，确保了与现有系统的兼容性，同时充分利用了Python和MPh库的优势，为热仿真分析提供了一个强大而灵活的工具。
